# Lodash - Array - Day I

{% method %}
## chunk 一维数组拆分成定长区块的二维数组

万万没想到，第一个函数就遇坑。函数定义比官方说明的用法多了一个 `guard` ?

这是这个参数的说明：`@param- {Object} [guard] Enables use as an iteratee for methods like _.map.`

看来要到 `_.map` 方法那里去找答案。

> Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues, _.reject, and _.some.
>
> The guarded methods are:
ary, chunk, curry, curryRight, drop, dropRight, every, fill, invert, parseInt, random, range, rangeRight, repeat, sampleSize, slice, some, sortBy, split, take, takeRight, template, trim, trimEnd, trimStart, and words

简单来讲，就是 chunk 函数支持作为迭代函数放入 map 函数的第二个参数，直接使用的时候是用不着这个参数的，所以没写在文档中。这类可作为迭代函数的函数，会包含一个判断 `guard ? isIterateeCall(array, size, guard) : size === undefined`。

chunk 函数中还调用了两类私有函数，分别是 `native*` 和 `base*`。其中 native 类是直接调用原生方法，如 `nativeMax = Math.max`，而 base 类是自定义方法，如 `baseSlice`。除此之外有调用 `toInteger` 不过这不是个私有方法，属于 Lang 部分。

{% sample lang="js" %}
官方用法：
```js
_.chunk(array, [size=1])
```
函数定义：
```js
function chunk(array, size, guard)
```
迭代函数：
```js
iteratee = (value, index|key, collection) => {}
```
被用作迭代函数：
```js
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
    ) {
        return eq(object[index], value);
    }
    return false;
}
```
{% endmethod %}

{% method %}
## compact 过滤假值

假值：false, null, 0, "", undefined, NaN

{% sample lang="js" %}
```js
_.compact(array)
```
{% endmethod %}

{% method %}
## concat （ES6 中有语法糖替代）

{% sample lang="js" %}
```js
_.concat(array, [values])
```
ES6：
```
const b = _.concat(a, 1, 2, 3)
// 等价于
const b = [...a, 1, 2, 3]
```
{% endmethod %}
