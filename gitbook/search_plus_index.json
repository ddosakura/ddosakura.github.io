{"./":{"url":"./","title":"Welcome","keywords":"","body":"DDoSakura's Gitbook Welcome to DDoSakura's Gitbook \r console.log(\"Hello World!\");\r Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-07-31 14:53:13 "},"gitbook.html":{"url":"gitbook.html","title":"Gitbook 说明","keywords":"","body":"Gitbook 说明 😏 安装 CLI Plugin Serve Build 使用的插件列表 默认 追加 插件的用法 配置 Style book.json TO DO 安装 CLI **[terminal] **[prompt root@pc]**[path ~/gitbook]**[delimiter $ ]**[command npm install gitbook-cli -g] Plugin **[terminal] **[prompt root@pc]**[path ~/gitbook]**[delimiter $ ]**[command gitbook install .] Serve **[terminal] **[prompt root@pc]**[path ~/gitbook]**[delimiter $ ]**[command gitbook serve] Build **[terminal] **[prompt root@pc]**[path ~/gitbook]**[delimiter $ ]**[command gitbook build] 使用的插件列表 默认 font-settings livereload [info] 部分默认插件已移除 lunr search sharing highlight 追加 [x] Search Plus - 支持中文搜索 [x] Prsim - 使用 Prism.js 高亮代码 [x] Advanced Emoji - 支持 emoji 表情 [x] Github - 添加github图标 [x] KaTex - 支持数学公式 [x] Include Codeblock - 用代码块显示包含文件的内容 [x] Splitter - 使侧边栏的宽度可以自由调节 [ ] Mermaid-gb3 - 支持渲染 Mermaid 图表 [ ] Puml - 支持渲染 uml 图 [ ] Graph - 使用 function-plot 绘制数学函数图 [ ] Chart - 绘制图形 [x] Sharing-plus - 分享当前页面 [x] Tbfed-pagefooter - 为页面添加页脚 [x] Expandable-chapters-small - 使左侧的章节目录可以折叠 [x] Sectionx - 将页面分块显示 [x] Donate - 打赏插件 [x] Simple-page-toc - 自动生成本页的目录结构 [x] Anchors - 添加 Github 风格的锚点 [x] Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮 [x] Sitemap-general - 生成sitemap [x] Todo - 添加 Todo 功能 [x] Terminal - 模拟终端样式 [x] Alerts - 添加不同 alerts 样式的 blockquotes [ ] Include-csv - 显示 csv 文件内容 [ ] Musicxml - 支持 musicxml 格式的乐谱渲染 [x] Rss - 添加 rss 订阅功能 [ ] theme-api 编写 API 文档 [x] runkit 插件的用法 E=mc2 E=mc^2 E=mc​2​​ 部分插件的用法 Sectionx Include Codeblock 这篇文章里有许多插件的项目地址 theme-api runkit 配置 Style .book-summary ul.summary li.header { text-transform: none; } book.json { \"title\": \"DDoSakura Gitbook\", \"author\": \"DDoSakura\", \"description\": \"DDoSakura Gitbook\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"styles\": { \"website\": \"assets/styles/website.css\" }, \"structure\": { \"readme\": \"README.md\" }, \"links\": { \"sidebar\": { \"DDoSakura Domain\": \"https://ddosakura.github.io/\" } }, \"plugins\": [ \"-lunr\", \"-search\", \"-sharing\", \"-highlight\", \"search-plus\", \"prism\", \"advanced-emoji\", \"github\", \"katex\", \"include-codeblock\", \"splitter\", \"mermaid-gb3\", \"puml\", \"graph\", \"chart\", \"sharing-plus\", \"tbfed-pagefooter\", \"expandable-chapters-small\", \"sectionx\", \"donate\", \"simple-page-toc\", \"anchors\", \"anchor-navigation-ex\", \"sitemap-general\", \"todo\", \"terminal\", \"alerts\", \"include-csv\", \"musicxml\", \"rss\", \"theme-api\", \"runkit\" ], \"pluginsConfig\": { \"prism\": { \"ignore\": [] }, \"github\": { \"url\": \"https://github.com/ddosakura\" }, \"include-codeblock\": { \"template\": \"default\", \"unindent\": true, \"theme\": \"monokai\" }, \"chart\": { \"type\": \"c3\" }, \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": false, \"qzone\": false, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": false, \"whatsapp\": false, \"all\": [ \"douban\", \"facebook\", \"google\", \"hatenaBookmark\", \"instapaper\", \"line\", \"linkedin\", \"messenger\", \"pocket\", \"qq\", \"qzone\", \"stumbleupon\", \"twitter\", \"viber\", \"vk\", \"weibo\", \"whatsapp\" ] }, \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy DDoSakura 2019\", \"modify_label\": \"修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sectionx\": { \"tag\": \"b\" }, \"donate\": { \"wechat\": \"/gitbook/assets/images/weixin.jpg\", \"alipay\": \"/gitbook/assets/images/alipay.jpg\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true }, \"anchor-navigation-ex\": { \"showLevel\": false, \"associatedWithSummary\": true, \"printLog\": false, \"multipleH1\": true, \"mode\": \"float\", \"showGoTop\": true, \"float\": { \"floatIcon\": \"fa fa-navicon\", \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": { \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } }, \"sitemap-general\": { \"prefix\": \"https://ddosakura.github.io/gitbook\" }, \"terminal\": { \"copyButtons\": false, \"fade\": false, \"style\": \"flat\" }, \"rss\": { \"title\": \"DDoSakrua's GitBook\", \"description\": \"DDoSakrua's GitBook\", \"author\": \"DDoSakrua\", \"feed_url\": \"https://ddosakura.github.io/gitbook/rss\", \"site_url\": \"https://ddosakura.github.io/gitbook/\", \"categories\": [ \"gitbook\" ] }, \"theme-api\": { } } } TO DO [x] 建 git 仓库 [x] 放入 ddosakura.github.io [ ] Gitbook 插件测试 [ ] CI Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-07-31 10:59:40 "},"day_by_day/lodash/":{"url":"day_by_day/lodash/","title":"lodash","keywords":"","body":"每天学点 Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。 一直以来对 lodash 的使用都挺随缘的，文档也没有全部过过一遍，只是想着——嗯，这个功能挺常见的，应该有吧——的心态去用的。 官网 中文 按文档的划分，目前(4.17.x) lodash 分为十三个部分，403 个方法： [ ] Array 数组 [ ] Collection [ ] Date [ ] Function [ ] Lang [ ] Math [ ] Number [ ] Object [ ] Seq [ ] String [ ] Util [ ] Properties [ ] Methods 原则上每个部分的学习笔记按照学习日期划分，但文档在每个部分中的方法按照字典序排列，可能出现相关的函数不临近的情况，在这种情况下会写入之前的部分。 除此之外，单独提取一个 Base 部分，用于分析 lodash 使用的原生方法、私有方法 [ ] Base Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-02 11:07:40 "},"day_by_day/lodash/array/":{"url":"day_by_day/lodash/array/","title":"Array","keywords":"","body":"Lodash - Array 数组 Part number I 3 II 9 III 9 + 1 + 2 (+4) 括号中是非数组部分的函数 Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-04 17:07:39 "},"day_by_day/lodash/array/20190731.html":{"url":"day_by_day/lodash/array/20190731.html","title":"Part I","keywords":"","body":"Lodash - Array - Part I chunk 一维数组拆分成定长区块的二维数组 万万没想到，第一个函数就遇坑。函数定义比官方说明的用法多了一个 guard ? 这是这个参数的说明：@param- {Object} [guard] Enables use as an iteratee for methods like _.map. 看来要到 _.map 方法那里去找答案。 Many lodash methods are guarded to work as iteratees for methods like .every, .filter, .map, .mapValues, .reject, and .some. The guarded methods are: ary, chunk, curry, curryRight, drop, dropRight, every, fill, invert, parseInt, random, range, rangeRight, repeat, sampleSize, slice, some, sortBy, split, take, takeRight, template, trim, trimEnd, trimStart, and words 简单来讲，就是 chunk 函数支持作为迭代函数放入 map 函数的第二个参数，直接使用的时候是用不着这个参数的，所以没写在文档中。这类可作为迭代函数的函数，会包含一个判断 guard ? isIterateeCall(array, size, guard) : size === undefined。 chunk 函数中还调用了两类私有函数，分别是 native* 和 base*。其中 native 类是直接调用原生方法，如 nativeMax = Math.max，而 base 类是自定义方法，如 baseSlice。除此之外有调用 toInteger 不过这不是个私有方法，属于 Lang 部分。 官方用法： _.chunk(array, [size=1]) 函数定义： function chunk(array, size, guard) 迭代函数： iteratee = (value, index|key, collection) => {} 被用作迭代函数： function isIterateeCall(value, index, object) { if (!isObject(object)) { return false; } var type = typeof index; if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object) ) { return eq(object[index], value); } return false; } compact 过滤假值 假值：false, null, 0, \"\", undefined, NaN _.compact(array) concat （ES6 中有语法糖替代） _.concat(array, [values]) ES6： const b = _.concat(a, 1, 2, 3) // 等价于 const b = [...a, 1, 2, 3] Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-01 14:17:13 "},"day_by_day/lodash/array/20190801.html":{"url":"day_by_day/lodash/array/20190801.html","title":"Part II","keywords":"","body":"Lodash - Array - Part II difference、pull、without 系列 difference、differenceBy、differenceWith 过滤元素 过滤 array 数组，values 为需要过滤的值列表（黑名单）。 By: 使用迭代函数对 array 及 values 处理后再比较 With: 自定义比较函数，常用函数为 _.Equal （深比较） 三者基于 baseDifference 定制，其它用到的私有函数有 baseRest、baseFlatten、getIteratee： base* 应该是一系列方法的基函数 getIteratee 与 Util 部分的 _.iteratee 有关 By、With 还用到了 _.last 来获取 values 的最后一个元素，应该是配合 baseRest 使用的 function baseDifference(array, values, iteratee, comparator) _.difference(array, [values]) _.differenceBy(array, [values], [iteratee=_.identity]) _.differenceWith(array, [values], [comparator]) baseDifference baseDifference 用到了 arrayMap、baseUnary、arrayIncludes/arrayIncludesWith iteratee 未定义则不执行 comparator 若存在，则置变量 isCommon 为 false [info] 存疑、解疑 这里有一个语句不明白 isCommon && computed === computed，作用应该是根据 isCommon 判断使用 === 还是 comparator 函数来对 value 进行比较 使用 arrayIncludes/arrayIncludesWith 函数来判断 。 首先确定 && 和 === 的优先级，因为 false && true === false 为 false，所以先算 ===，若 computed === computed 恒为真，则 isCommon && computed === computed 等价于 isCommon && true 等价于 isCommon，不明白这样写有什么意义。 参考链接：https://www.cnblogs.com/hahazexia/p/9834888.html 这个是用来判断 NaN 的，isNaN 在非数字参数时也返回 true，不能替代。这个语句避免了 computed === computed 为假的参数进行 === 比较，改用 arrayIncludes/arrayIncludesWith 判断。 pull、pullAll、pullAllBy、pullAllWith、pullAt、without 过滤元素 pull 系列、without 和 different 系列作用是一样的，区别只在 pull 系列使用 _.remove 从而改变了 array 变量本身，而 different 系列和 without 则是返回全新数组。 命名稍微有点迷，对应关系如下： pull 系列 different 系列及 without pull without pullAll difference pullAllBy differenceBy pullAllWith differenceWith [info] 存疑、解疑 实测 pullAll 确实对标 difference，但是以 difference 为例，源代码是 baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) 对 values 变量做了 flatten，但是整个函数包裹在 baseRest 下。 我本来理解因该是一个个传值，通过 rest，变成数组，通过 flatten，又恢复才对，但实测就是需要传数组。 阅读到 basePullAll 时想起 baseDifference 的函数签名 function baseDifference(array, values, iteratee, comparator)，算是弄明白了，这里应该是吧数组和 iteratee/comparator 组合成数组，然后取 iteratee/comparator （By、With时），打平数组取第一个值就是最开始传的数组本身。 源码和实证现象符合，这里就是文档出了点小差错了。 至于 pull 和 pullAll 的关系，可以类比 .call 和 .apply 的关系，一个是传多个参数，一个是传一个数组，源代码是这样的 —— var pull = baseRest(pullAll);。 pullAt 没有对应的，作用是根据 index 来移除，返回的参数也并非 array 而是被移除的元素构成的数组。 pullAll、pullAllBy、pullAllWith 三者基于 basePullAll 函数 function basePullAll(array, values, iteratee, comparator) _.pull(array, [values]) _.pullAll(array, values) _.pullAllBy(array, values, [iteratee=_.identity]) _.pullAllWith(array, values, [comparator]) _.pullAt(array, [indexes]) _.without(array, [values]) basePullAll baseDifference 用到了 baseIndexOfWith/baseIndexOf、copyArray、arrayMap、indexOf、Array.prototype.splice pullAt、basePullAt pullAt 基于 basePullAt，用到了 flatRest、baseAt、arrayMap、isIndex、compareAscending basePullAt 用到了isIndex、Array.prototype.splice、baseUnset Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-02 21:18:20 "},"day_by_day/lodash/array/20190804.html":{"url":"day_by_day/lodash/array/20190804.html","title":"Part III","keywords":"","body":"Lodash - Array - Part III 切片系列 看到 _.drop 函数的时候用到了切片数组（slice）这个词，回顾之前的十来个函数似乎都是和数组遍历有关的，所以把切片类的函数单独拿出来分成一个部分。 slice 名字就叫 slice，最基本的切片操作，不够比起 go 等其他语言自带的原生切片写法表现力上差了些。 function baseSlice(array, start, end) _.slice(array, [start=0], [end=array.length]) Example: const b = _.slice(a, start, end) b := a[start:end] drop 系列 lodash 有一类函数中包含 Right，一般一个系列的函数默认是从左开始处理 既然是切片系列，自然都是基于 baseSlice 实现的，实现切片功能用了这么多函数，也是我说切片写法表现力差的原因。 While 没有直接基于 baseSlice 实现，而是基于 baseWhile 实现，baseWhile 才是直接基于 baseSlice 实现。猜测有 While 这个后缀的函数都是切片系列这个大家族的。 断言 predicate：Array|Function|Object|string predicate（断言函数）调用3个参数： (value, index|key, array|collection) function baseWhile(array, predicate, isDrop, fromRight) _.drop(array, [n=1]) _.dropRight(array, [n=1]) _.dropRightWhile(array, [predicate=_.identity]) _.dropWhile(array, [predicate=_.identity]) take 系列 搜索了一下 baseWhile 果然发现了其它切片函数。下面是 dropRight 和 take 的源码对比，何必呢。 function dropRight(array, n, guard) { var length = array ? array.length : 0; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); n = length - n; return baseSlice(array, 0, n function take(array, n, guard) { if (!(array && array.length)) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, 0, n 就算是为了在 _.map 类的函数中使用，似乎也没太大意义： // 这样写是挺方便的啦 map([[1, 2, 3], [1, 2, 3]], take) // [[1], [1]] // 但这样也没差啊 map([[1, 2, 3], [1, 2, 3]], v => slice(v, 0, 1)) // [[1], [1]] // 而且一旦有改动 map([[1, 2, 3], [1, 2, 3]], v => slice(v, 0, 2)) // [[1, 2], [1, 2]] // 你也得传参啊 map([[1, 2, 3], [1, 2, 3]], v => take(v, 2)) // [[1, 2], [1, 2]] function baseWhile(array, predicate, isDrop, fromRight) _.take(array, [n=1]) _.takeRight(array, [n=1]) _.takeRightWhile(array, [predicate=_.identity]) _.takeWhile(array, [predicate=_.identity]) fill - 填充 会改变原数组 基于 baseFill，base* 类函数是 lodash 真正的核心，即使 baseFill 只服务了 fill 这一个函数 想到一个不算恰当的类比，假如 base* 是微服务，那 public 函数则是 api 网关 _.fill(array, value, [start=0], [end=array.length]) 查询系列 查询系列的特殊之处在于其横跨了 Array、Collection、Object Last 后缀和 Right 后缀的意义一致 三者的交叉点在于 Collection 部分的 find，这是返回匹配元素的，而 findIndex 返回数组的索引，findKey 返回对象的键值 findIndex([11, 22, 33]) // 0 find([11, 22, 33]) // 11 findKey([11, 22, 33]) // \"0\" 其中 find 与 findIndex 有直接联系： var find = createFind(findIndex); create* 这类函数似乎都是高阶函数 createFind 就是简单的根据索引取元素的一层包装 findIndex 基于 baseFindIndex，findKey 基于 baseFindKey，常规操作 baseFindIndex 和 baseFindKey 都是简单的遍历，baseFindKey 稍微特殊一些，会接收一个 eachFunc 参数（baseForOwn/baseForOwnRight），基于 baseFor/baseForRight var baseFor = createBaseFor(); var baseForRight = createBaseFor(true); createBaseFor 这个高阶函数只是接收一个 fromRight 参数决定从哪边开始遍历而已 差点漏了一点，baseForOwn -> baseFor 的过程中传递了 _.keys 作为遍历时获取 key 列表的函数 function baseForOwn(object, iteratee) { return object && baseFor(object, iteratee, keys); } Array： _.findIndex(array, [predicate=_.identity], [fromIndex=0]) _.findLastIndex(array, [predicate=_.identity], [fromIndex=array.length-1]) Collection： _.find(collection, [predicate=_.identity], [fromIndex=0]) _.findLast(collection, [predicate=_.identity], [fromIndex=collection.length-1]) Object： _.findKey(object, [predicate=_.identity]) _.findLastKey(object, [predicate=_.identity]) Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-04 17:45:57 "},"day_by_day/lodash/array/summary.html":{"url":"day_by_day/lodash/array/summary.html","title":"总结","keywords":"","body":"总结 guard By/With base SameValueZero 个人感觉 切片系列 的函数“用力过猛”，九个函数就干了一件事，自然而然就想到了 lodash-core，只包含了 slice 一个。其实在看 lodash 源码前，对 lodash 多达 403 个的函数期望都很高，毕竟诸如防抖(debounce)、节流(throttle)函数声名在外，现在看来，其冗余还是比较重的（不过 core 版没有 debounce/throttle 这类函数，这个之后再谈）。 会对传入的 array 造成改变的函数 pull 系列 fill Question [x] baseDifference 之 isCommon && computed === computed [x] difference 传参问题 Tips 阅读源码过程中也找了一些资料，一开始这几个简书搜到了好几次： https://www.jianshu.com/u/64604bb9c80d https://www.jianshu.com/u/c73166fee788 不约而同的在 difference 处断更 2333，希望自己能坚持下去。 这个博客就比较赞了： https://www.cnblogs.com/hahazexia/category/1246962.html Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-08-04 17:49:25 "},"micro_frontend/framework/":{"url":"micro_frontend/framework/","title":"Framework","keywords":"","body":"Skrfront Micro Micro Frontend Framework based single-spa 项目地址 Copyright © DDoSakura 2019 all right reserved，powered by Gitbook修订时间： 2019-07-31 14:58:16 "}}